/*
 * Copyright (C) 2008 Beelucid Software, LLC.
 * All rights reserved.
 *
 * The software in this package is published under the terms of the BSD
 * style license a copy of which is generated into the LICENSE.txt file.
 *
 * Created on June 20, 2008 by Megan Adams
 */
package ouput.beelucid; 
import ouput.beelucid.*;

import ouput.beelucid.plugin.MsgBoxStyle; 
import ouput.beelucid.plugin.MsgBoxResult; 
import java.text.DateFormat; 
import java.text.SimpleDateFormat; 
import ouput.beelucid.plugin.ArgumentException; 
import java.util.Formatter; 
import ouput.beelucid.plugin.InvalidCastException; 
import ouput.beelucid.plugin.OverflowException; 
import java.lang.NumberFormatException; 
import ouput.beelucid.plugin.VisualBasic.CompareMethod; 
import java.nio.CharBuffer; 
import java.text.*; 
import java.util.Date; 
import java.util.regex.Pattern; 
import java.util.regex.Matcher; 

/**
 * <code>SystemBridge</code> is a BeeLucid 'bridge class' which contains stubs and as well as some implementations for 
 * library and system functions, some generated by default and some generated on the fly because they were identified in code.
 */
public final class SystemBridge {
    /**
     * Support for Visual Basic 'Like' operator
     */
    public static boolean Like(String src, String pat) {
        Pattern p = Pattern.compile(pat);
        char[] chars = src.toCharArray();
        CharBuffer cb = CharBuffer.wrap(chars);
        Matcher m = p.matcher(cb);
        return m.find();
    }
    /**
     * Return the current time according to Calendar.
     */
    public static Date Now() {
        return java.util.Calendar.getInstance().getTime();
    }
    /**
     * @return 0 as the lower bound for the array (for any dimension).
     * Note 0 is always the lower bound in the Java context.
     */
    public static int LBound(Object  p0, int  p1) {
        return 0;
    }
    /**
     * @return 0 as the lower bound for the array (for any dimension).
     * Note 0 is always the lower bound in the Java context.
     */
    public static int LBound(Object  p0) {
        return 0;
    }
    /**
     * @return upper bound for array at rank specified by parameter.
     */
    public static int UBound(ouput.beelucid.ArrayBridge  p0, int  p1) {
        return p0.getUpperBound(p1-1);
    }
    /**
     * @return upper bound for array at dimension 0.
     */
    public static int UBound(ouput.beelucid.ArrayBridge  p0) {
        return p0.getUpperBound(0);
    }
    /**
     * @return upper bound for array at rank specified by parameter.
     */
    public static int UBound(Object  p0, int  p1) {
        return (new ArrayBridge(p0)).getUpperBound(p1-1);
    }
    /**
     * @return upper bound for array at dimension 0.
     */
    public static int UBound(Object  p0) {
        return (new ArrayBridge(p0)).getUpperBound(0);
    }
    /**
     * Display MsgBox with message and title.
     */
    public static int MsgBox(Object  msg, String  title) {
        return MsgBox(msg, MsgBoxStyle.OKOnly, title);
    }
    /**
     * Display MsgBox with message.
     */
    public static int MsgBox(Object  msg) {
        return MsgBox(msg, MsgBoxStyle.OKOnly, "");
    }
    /**
     * Display a message box with text, title, and style.
     */
    public static int MsgBox(Object  msg, int  style, String  title) {
        // Java has option type, message type, and return values.
		// .Net has a bit flag for styles.
		// OKOnly is the default style.
		int msgType = 0xF0 & style;
		int optionType  = 0x0F & style;
		int jmsgType, joptionType;
		switch (optionType) {
		default:
		case MsgBoxStyle.OKOnly:
			joptionType = javax.swing.JOptionPane.DEFAULT_OPTION;
			break;
		case MsgBoxStyle.OKCancel:
			joptionType = javax.swing.JOptionPane.OK_CANCEL_OPTION;
			break;
		case MsgBoxStyle.AbortRetryIgnore:
			joptionType = javax.swing.JOptionPane.OK_CANCEL_OPTION;
			break;
		case MsgBoxStyle.YesNoCancel:
			joptionType = javax.swing.JOptionPane.YES_NO_CANCEL_OPTION;
			break;
		case MsgBoxStyle.YesNo:
			joptionType = javax.swing.JOptionPane.YES_NO_OPTION;
			break;
		case MsgBoxStyle.RetryCancel:
			joptionType = javax.swing.JOptionPane.OK_CANCEL_OPTION;
			break;
		}
		switch (msgType) {
		case MsgBoxStyle.Critical:
			jmsgType = javax.swing.JOptionPane.ERROR_MESSAGE;
			break;
		case MsgBoxStyle.Question:
			jmsgType = javax.swing.JOptionPane.QUESTION_MESSAGE;
			break;
		case MsgBoxStyle.Exclamation:
			jmsgType = javax.swing.JOptionPane.WARNING_MESSAGE;
			break;
		case MsgBoxStyle.Information:
		default:
			jmsgType = javax.swing.JOptionPane.INFORMATION_MESSAGE;
		break;
		}
		int result = javax.swing.JOptionPane.showOptionDialog(null,
				msg, title, joptionType, jmsgType,
				null, null, null) ;
		switch (result) {
		case javax.swing.JOptionPane.YES_OPTION:
			MsgBoxResult.Yes();
			break;
		case javax.swing.JOptionPane.NO_OPTION:
			result = MsgBoxResult.No();
			break;
		case javax.swing.JOptionPane.CANCEL_OPTION:
			result = MsgBoxResult.Cancel();
			break;
		case javax.swing.JOptionPane.CLOSED_OPTION:
			result = MsgBoxResult.Abort();
			break;
		default:
			result = MsgBoxResult.OK();
			break;
		}
		return result;
    }
    /**
     * dateFormat() with a pattern.
     */
    public static Date dateFormat(String  dateString, String  pattern) {
        DateFormat dateFormat = new SimpleDateFormat(pattern);
		try  {
			return dateFormat.parse(dateString);
		}
		catch (ParseException e)  {
			e.printStackTrace();
		}
		return new Date();
    }
    /**
     * Support for creating a Date object from a String.
     * Note the parse will fail if the input String 
     * does not match the pattern.
     * Sample Dates with their patterns:
     * 01/17/05          "MM/dd/yy"
     * 01-17-05          "MM-dd-yy"
     * 17-Jan-05         "dd-MMM-yy"
     * 2005.01.29.09.15.09   "yyyy.MM.dd.HH.mm.ss"
     * Tue, 29 Jan 2002  "E, dd MMM yyyy"
     * 
     * @param dateString
     * @return a Date.
     */
    public static Date dateFormat(String  dateString) {
        DateFormat dateFormat = new SimpleDateFormat("MM/dd/yy");
		try  {
			return dateFormat.parse(dateString);
		}
		catch (ParseException e)  {
			return dateFormat(dateString, "MM-dd-yy");
		}
    }
    /**
     * Return the character associated with the integer code.
     */
    public static char Chr(int  p0) {
        return (Character.toChars(p0))[0];
    }
    /**
     * Return the character associated with the integer code.
     */
    public static char ChrW(int  p0) {
        return (Character.toChars(p0))[0];
    }
    /**
     * Return tab.
     */
    public static String vbTab() {
        return "\t";
    }
    /**
     * Return <cr><lf>.
     */
    public static String vbCrLf() {
        return "\r\n\r";
    }
    /**
     * Return <cr>.
     */
    public static String vbCr() {
        return "\r\n";
    }
    /**
     * Return <lf>.
     */
    public static String vbLF() {
        return "\r";
    }
    /**
     * Return the length of the String.
     */
    public static int Len(String  p0) {
        return p0.length();
    }
    /**
     * Returns a string containing a specified number of characters from the left side of a string.
     */
    public static String Left(String  p0, int  p1) {
        if (p1 > p0.length()) return p0;
		if (p1 == 0) return "";
		return p0.substring(0,p1);
    }
    /**
     * TBD
     */
    public static String Right(String  p0, int  p1) {
        return "";
    }
    /**
     * Returns an Integer value representing the character code corresponding to a character.
     */
    public static int Asc(char  p0) {
        return Asc(new Character(p0).toString());
    }
    /**
     * Returns an Integer value representing the character code corresponding to a character.
     */
    public static int Asc(String  p0) {
        if (p0 == null || p0.isEmpty())
			throw new ArgumentException("Invalid input String");
		return p0.codePointAt(0);  
    }
    /**
     * Returns an Integer value representing the character code corresponding to a character.
     */
    public static int AscW(char  p0) {
        return Asc(new Character(p0).toString());
    }
    /**
     * Returns an Integer value representing the character code corresponding to a character.
     */
    public static int AscW(String  p0) {
        return Asc(p0);
    }
    /**
     * Returns an expression formatted as a number.
     */
    public static String FormatNumber(Object  num, int  precision) {
        double newDbl = DoubleBridge.fromObject(num);
		return (new Formatter().format("%." + precision + "f", newDbl)).toString();
    }
    /**
     * @param p0 an Object
     * @return the number contained in the Object as a Double.
     */
    public static double Val(Object  p0) {
        return SystemBridge.Val(p0.toString());
    }
    /**
     * @param p0 a char
     * @return the number contained in the char as a Double.
     */
    public static double Val(char  p0) {
        String s = "" + p0;
		return SystemBridge.Val(s.toString());
    }
    /**
     * Returns the number contained in the String as a Double.
     */
    public static double Val(String  src) {
        if (src == null || src.isEmpty())
			throw new InvalidCastException("Number badly formed");
		src = src.replaceAll("\\s", "");
		boolean octal = false, hex = false;
		if (src.charAt(0) == '&') {
			octal = src.charAt(1) == 'O' || src.charAt(1) == 'o';
			hex = src.charAt(1) == 'H' || src.charAt(1) == 'h';
			src = src.substring(2);
		}
		String sign = "";
		if (src.charAt(0) == '-' || src.charAt(0) == '+' ) {
			sign = sign + src.charAt(0);
			src = src.substring(1);
		}
		int doti = src.indexOf('.');
		doti = src.indexOf('.', doti+1);
		if (doti != -1 ) {
			src = src.substring(0, doti);	// skip anything after the second '.'
		}
		char[] in = src.toCharArray();
		String rtn = sign;
		for (char c : in) {
			if (Character.isDigit(c) || c == '.')
				rtn += c;
			else {
				break;
			}
		}
		if (rtn.isEmpty())
			throw new InvalidCastException("Number badly formed");
		try {
			if (hex) return Double.longBitsToDouble(Long.parseLong(rtn, 16));
			if (octal) return Double.longBitsToDouble(Long.parseLong(rtn, 8));
			return Double.parseDouble(rtn);
		}
		catch (NumberFormatException e) {
			throw new OverflowException(e.getMessage());
		}
    }
    /**
     * Returns one of two objects, depending on the evaluation of expr.
     */
    public static Object IIf(boolean  expr, Object  truePart, Object  falsePart) {
        return (expr) ? truePart : falsePart;
    }
    /**
     * Format the string by replacing {<n>} with parameter <n>. Other specifications ignored.
     */
    public static String Format(String  p0, String []  p1) {
        if (p0 == null || p1 == null) return "";
		for (int i=0; i < p1.length; i++) {
			if(p1[i] == null)
				p0 = p0.replaceAll("\\{\\s*"  + i + "[^\\}]*\\}", "");
			else
				p0 = p0.replaceAll("\\{\\s*"  + i + "[^\\}]*\\}", p1[i]);
		}
		return p0;

    }
    /**
     * Support for 'Mid' statement.
     */
    public static String Mid(String  target, int  start, String  subStr) {
        return SystemBridge.Mid(target,start,subStr.length(),subStr);
    }
    /**
     * Support for 'Mid' statement.
     */
    public static String Mid(String  target, int  start, int  len, String  subStr) {
        if (start < 2) return "";
	String rtn = target.substring(0,start-1);
	int subLen = (len > target.length() - start +1 ? target.length() - start +1 : len);
	rtn = rtn + subStr.substring(0,subLen);
	if (rtn.length() < target.length())
	rtn = rtn + target.substring(rtn.length());
	return rtn;
    }
    /**
     * Support for 'Mid' function.
     */
    public static String Mid(String  str, int  start) {
        if (start < 2) return "";
		return str.substring(start-1);
    }
    /**
     * Support for 'Mid' function.
     */
    public static String Mid(String  str, int  start, int  length) {
        if (start < 2) return "";
		String rtn = str.substring(start-1);
		length = (length > str.length() - start +1 ? str.length() - start +1 : length);
		rtn = rtn.substring(0,length);
		return rtn;
    }
    /**
     * Return the 1-based index of the start of one string within another.
     */
    public static int InStr(String  string1, String  string2, int  cm) {
        int rtn = 0;
		if (cm == CompareMethod.Binary())
			rtn = (string1.indexOf(string2) + 1);
		else if (cm == CompareMethod.Text()) {
			rtn = string1.toLowerCase().indexOf(string2.toLowerCase()) +1;
		}
		return ((rtn == -1) ? 0 : rtn);
    }
    /**
     * Return the 1-based index of the start of one string within another.
     */
    public static int InStr(int  start, String  string1, String  string2) {
        int rtn = (string1.indexOf(string2, start-1)+1);
		return ((rtn == -1) ? 0 : rtn);
    }
    /**
     * Return the 1-based index of the start of one string within another.
     */
    public static int InStr(String  string1, String  string2) {
        int rtn =(string1.indexOf(string2) + 1);
		return ((rtn == -1) ? 0 : rtn);
    }
    /**
     * Return the 1-based index of the start of one string within another.
     */
    public static int InStr(int  start, String  string1, String  string2, int  cm) {
        int rtn = 0;
		if (cm == CompareMethod.Binary())
			rtn = (string1.indexOf(string2, start-1)+1);
		else if (cm == CompareMethod.Text()) {
			rtn = string1.toLowerCase().indexOf(string2.toLowerCase(), start-1) +1;
		}
		return ((rtn == -1) ? 0 : rtn);
    }
    /**
     * Return the number as a String.
     */
    public static String Str(short  p0) {
        return new Short(p0).toString();
    }
    /**
     * Return the number as a String.
     */
    public static String Str(byte  p0) {
        return new Byte(p0).toString();
    }
    /**
     * Return the number as a String.
     */
    public static String Str(long  p0) {
        return Long.toString(p0);
    }
    /**
     * Return the number as a String.
     */
    public static String Str(float  p0) {
        return Float.toString(p0);
    }
    /**
     * Return the number as a String.
     */
    public static String Str(double  p0) {
        return Double.toString(p0);
    }
    /**
     * Return the number as a String.
     */
    public static String Str(int  p0) {
        return Integer.toString(p0);
    }
    /**
     * Calculate internal rate of return (IRR) using cash flows that occur at regular intervals, such as monthly or annually.
     * The internal rate of return is the interest rate received for an investment consisting of payments and receipts that occur at regular intervals.
     * <p>
     * Method: Newton-Raphson technique. Formula: sum(cashFlow(i) / (1 + IRR)^i)
     * 
     * @param cashFlows Cash flow values. Must contain at least one negative value (cash paid) and one positive value (cash received).
     * @param estimatedResult Optional guess as start value (default (if value is Double.NaN): 0.1 = 10%; if value is negative: 0.5).
     * As the formula to calculate IRRs can have multiple solutions, an estimated result (guess) can help find the result we are looking for.
     * @return Internal rate of return (0.25 = 25%) or Double.NaN if IRR not computable.
     * @see <a href="http://forum.java.sun.com/thread.jspa?forumID=1&threadID=219441">IRR financial function in Java</a>
     * @see <a href="http://de.wikipedia.org/wiki/Interner_Zinsfu%C3%9F">Interner Zinsfu?</a>.
     */
    public static double IRR(double []  cashFlows, double  estimatedResult) {
        double result = Double.NaN;
		if (cashFlows != null && cashFlows.length > 0) {
			//check if business startup costs is not zero:
			if (cashFlows[0] != 0.0) {
				final double noOfCashFlows = cashFlows.length;
				double sumCashFlows = 0.0;
				//check if at least 1 positive and 1 negative cash flow exists:
				int noOfNegativeCashFlows = 0;
				int noOfPositiveCashFlows = 0;
				for (int i = 0; i < noOfCashFlows; i++) {
					sumCashFlows += cashFlows[i];
					if (cashFlows[i] > 0) {
						noOfPositiveCashFlows++;
					} else if (cashFlows[i] < 0) {
						noOfNegativeCashFlows++;
					}
				}
				if (noOfNegativeCashFlows > 0 && noOfPositiveCashFlows > 0) { //at least 1 negative and 1 positive cash flow available?
						//set estimated result:
							double irrGuess = 0.1; //default: 10%
							if (estimatedResult != Double.NaN) {
								irrGuess = estimatedResult;
								if (irrGuess <= 0.0) irrGuess = 0.5;
							}
							//initialize first IRR with estimated result:
							double irr = 0.0;
							if (sumCashFlows < 0) { //sum of cash flows negative?
								irr = -irrGuess;
							} else { //sum of cash flows not negative
								irr = irrGuess;
							}
							//iteration:
							final double minDistance = .0000001; //the smaller the distance, the smaller the interpolation error
							final double cashFlowStart = cashFlows[0]; //business startup costs
							final int maxIteration = 50;
							boolean wasHi = false;
							double cashValue = 0.0; //cash value 
							for (int i = 0; i <= maxIteration; i++) { //for each iteration
								//calculate cash value with current irr:
								cashValue = cashFlowStart; //init with startup costs
								for (int j = 1; j < noOfCashFlows; j++) { //for each cash floe
									cashValue += cashFlows[j] / java.lang.Math.pow(1.0 + irr, j);
								}//next cash flow
								if (java.lang.Math.abs(cashValue) < 0.01) { //cash value is nearly zero
									result = irr;
									break;
								}
								//adjust irr for next iteration:
								if (cashValue > 0.0) { //cash value > 0 => next irr > current irr
									if (wasHi) {
										irrGuess /= 2;
									}
									irr += irrGuess;
									if (wasHi) {
										irrGuess -= minDistance;
										wasHi = false;
									}
								} else { //cash value < 0 => next irr < current irr
									irrGuess /= 2;
									irr -= irrGuess;
									wasHi = true;
								}
								if (irrGuess <= minDistance) { //estimated result too small to continue => end calculation
									result = irr;
									break;
								}
							}//next iteration
				}//else: noOfNegativeCashFlows == 0 || noOfPositiveCashFlows == 0
			}//else: first cash flow is 0
		}//else: cashFlows unavailable
		return result;
    }
    /**
     * BeeLucid generated stub
     */
    public static Object ReadLine() {
		try {
			throw new Exception("unimplemented method");
		} 
		catch (Exception e) { 
			e.printStackTrace(); 
		}
		 // return default value for return type
		return null; 
	 }
}
